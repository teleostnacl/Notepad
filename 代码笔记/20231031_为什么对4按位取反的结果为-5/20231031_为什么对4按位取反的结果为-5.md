在计算机世界里，所有数据都是以二进制进行存储的，人们为了方便计算，定义了一套位运算的逻辑运算规则，其是可以对数的二进制位的直接操作。主要包括按位与、按位或、按位异或、按位取反、左移、带符号右移、无符号右移这几个运算规则。在Java和Kotlin中，其运算符分别如下：

|            |  JAVA   |  Kotlin  |
|:----------:|:-------:|:--------:|
|   按位与   |  a & b  | a and b  |
|   按位或   | a \| b  |  a or b  |
|  按位异或  |  a ^ b  | a xor b  |
|  按位取反  |   ~a    | a.inv()  |
|    左移    | a << b  | a shl b  |
| 带符号右移 | a >> b  | a shr b  |
| 无符号右移 | a >>> b | a ushr b |
本篇文章所涉及到的是按位取反运算，下面将对其进行叙述

# 按位取反
按位取反运算符可接受一个操作数，且此操作数必须是整型。如其命名，其运算规则就是将一个二进制整数的每个位都取反，即如果一个位上数为0，则结果中相同位上的数为1；原来为1时，结果就为0。因此，比如如下二进制数
`0000 1111 0011 1100 1001 0110`
其按位取反的结果为
`1111 0000 1100 0011 0110 1001`

如果直接对一个整数进行按位取反会是怎样的结果呢?我们先来看一下程序的执行结果
使用Kotlin Palyground在新沙箱，编写我们的测试程序，打印对4按位取反`4.inv()`的执行结果
![[对4按位取反的结果为-5.png]]
可以看到，程序的输出结果为-5，也即对4进行按位取反运算将得到-5。但这是怎么回事呢？

# 为什么对4按位取反的结果为-5
我们知道，在JAVA中，存储一个整型数使用4字节表示，也即32位，使用32位二进制数表示整形数。我们还知道，在计算机中，最高位是符号位，当为0时表示此为正整数；为1时表示此为负整数。因此JAVA的`int`型变量的取值范围为 $$-2^31 2^31 - 1$$
因此对于4来说，其在内存中表示即为
`0000 0000 0000 0100`