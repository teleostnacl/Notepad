在计算机世界里，所有数据都是以二进制进行存储的，人们为了方便计算，定义了一套位运算的逻辑运算规则，其是可以对数的二进制位的直接操作。主要包括按位与、按位或、按位异或、按位取反、左移、带符号右移、无符号右移这几个运算规则。在Java和Kotlin中，其运算符分别如下：

|            |  JAVA   |  Kotlin  |
|:----------:|:-------:|:--------:|
|   按位与   |  a & b  | a and b  |
|   按位或   | a \| b  |  a or b  |
|  按位异或  |  a ^ b  | a xor b  |
|  按位取反  |   ~a    | a.inv()  |
|    左移    | a << b  | a shl b  |
| 带符号右移 | a >> b  | a shr b  |
| 无符号右移 | a >>> b | a ushr b |
本篇文章所涉及到的是按位取反运算，下面将对其进行叙述

# 1.  按位取反
按位取反运算符可接受一个操作数，且此操作数必须是整型。如其命名，其运算规则就是将一个二进制整数的每个位都取反，即如果一个位上数为0，则结果中相同位上的数为1；原来为1时，结果就为0。因此，比如如下二进制数
`0000 1111 0011 1100 1001 0110`
其按位取反的结果为
`1111 0000 1100 0011 0110 1001`

如果直接对一个整数进行按位取反会是怎样的结果呢?我们先来看一下程序的执行结果。使用Kotlin Palyground在新沙箱，编写我们的测试程序，打印对4按位取反`4.inv()`的<center>执行结果</center>
![[对4按位取反的结果为-5.png]]

可以看到，程序的输出结果为-5，也即对4进行按位取反运算将得到-5。但这是怎么回事呢？

##  为什么对4按位取反的结果为-5
我们知道，在JAVA中，存储一个整型数使用4字节表示，也即32位，使用32位二进制数表示整形数。我们还知道，在计算机中，最高位是符号位，当为0时表示此为正整数；为1时表示此为负整数。因此JAVA的`int`型变量的取值范围为  $-2^{31} \sim 2^{31} - 1$，即$-2147483648 \sim 2147483647$
因此对于4来说，其使用4字节32位二进制表示则为
`0000 0000 0000 0000 0000 0000 0000 0100`
若对其进行按位取反，则是
`1111 1111 1111 1111 1111 1111 1111 1011`
把其转换成十进制数则为
$$ -(2^{30} + 2^{29} + 2^{28} + ... + 2^3 + 2^1 + 2^0)= -2147483643$$
同理，-5使用4字节32位二进制表示则为
`1000 0000 0000 0000 0000 0000 0000 0101`

显然，两数完全不相等，但为什么由程序计算出来的结果对4按位取反的结果为-5呢？

# 2. 计算机中对数的存储
对于一个整数，我们知道其可以是正数、零或负数。计算机领域里，在以二进制编码方式中，负数通常是通过符号位来表示的，即较高位为1表示负数，较高位为0表示正数。由于硬件电路的限制，逻辑门电路只有加法器，当以以上方式表示数，进行加减运算时，由于需要考虑符号位，使得硬件设计变得复杂。同时，由于0的存在，会出现+0和-0两种情况，在计算过程中会引入很多不必要的麻烦。

因此，在计算机中，存储一个数是用一个数的补码来表示，同时利用加法器计算减法运算，形如`a - b = a + ( - b )`，也是利用了补码的本质特性。、

## 2.1 原码、反码、补码的计算
### 2.1.1 原码
将一个整数转换成二进制数，就是其原码。

例如：
18 的原码为
`0001 0010`
-18的原码为
`1001 0010`

### 2.1.2 反码
反码对于正负数有所区别：
正数：反码=原码
负数：原码中除符号位外，按位取反。

例如：
18 的反码为
`0001 0010`
-18的反码为
`1110 1101`

### 2.1.3 补码
正数：补码=原码
负数：反码加1
例如：
18---->0001 0010
-18–1>1110 1110
