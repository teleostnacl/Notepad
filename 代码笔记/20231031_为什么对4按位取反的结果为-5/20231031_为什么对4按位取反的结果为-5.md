在计算机世界里，所有数据都是以二进制进行存储的，人们为了方便计算，定义了一套位运算的逻辑运算规则，其是可以对数的二进制位的直接操作。主要包括按位与、按位或、按位异或、按位取反、左移、带符号右移、无符号右移这几个运算规则。在Java和Kotlin中，其运算符分别如下：

|            |  JAVA   |  Kotlin  |
|:----------:|:-------:|:--------:|
|   按位与   |  a & b  | a and b  |
|   按位或   | a \| b  |  a or b  |
|  按位异或  |  a ^ b  | a xor b  |
|  按位取反  |   ~a    | a.inv()  |
|    左移    | a << b  | a shl b  |
| 带符号右移 | a >> b  | a shr b  |
| 无符号右移 | a >>> b | a ushr b |
本篇文章所涉及到的是按位取反运算，下面将对其进行叙述

# 1.  按位取反
按位取反运算符可接受一个操作数，且此操作数必须是整型。如其命名，其运算规则就是将一个二进制整数的每个位都取反，即如果一个位上数为0，则结果中相同位上的数为1；原来为1时，结果就为0。因此，比如如下二进制数
`0000 1111 0011 1100 1001 0110`
其按位取反的结果为
`1111 0000 1100 0011 0110 1001`

如果直接对一个整数进行按位取反会是怎样的结果呢?我们先来看一下程序的执行结果。使用Kotlin Palyground在新沙箱，编写我们的测试程序，打印对4按位取反`4.inv()`的<center>执行结果</center>
![[对4按位取反的结果为-5.png]]

可以看到，程序的输出结果为-5，也即对4进行按位取反运算将得到-5。但这是怎么回事呢？

##  为什么对4按位取反的结果为-5
我们知道，在JAVA中，存储一个整型数使用4字节表示，也即32位，使用32位二进制数表示整形数。我们还知道，在计算机中，最高位是符号位，当为0时表示此为正整数；为1时表示此为负整数。因此JAVA的`int`型变量的取值范围为  $-2^{31} \sim 2^{31} - 1$，即$-2147483648 \sim 2147483647$
因此对于4来说，其使用4字节32位二进制表示则为
`0000 0000 0000 0000 0000 0000 0000 0100`
若对其进行按位取反，则是
`1111 1111 1111 1111 1111 1111 1111 1011`
把其转换成十进制数则为
$$ -(2^{30} + 2^{29} + 2^{28} + ... + 2^3 + 2^1 + 2^0)= -2147483643$$
同理，-5使用4字节32位二进制表示则为
`1000 0000 0000 0000 0000 0000 0000 0101`

显然，两数完全不相等，但为什么由程序计算出来的结果对4按位取反的结果为-5呢？

# 2. 计算机中对数的存储
对于一个整数，我们知道其可以是正数、零或负数。计算机领域里，在以二进制编码方式中，负数通常是通过符号位来表示的，即较高位为1表示负数，较高位为0表示正数。由于硬件电路的限制，逻辑门电路只有加法器，当以以上方式表示数，进行加减运算时，由于需要考虑符号位，使得硬件设计变得复杂。同时，由于0的存在，会出现+0和-0两种情况，在计算过程中会引入很多不必要的麻烦。

因此，在计算机中，存储一个数是用一个数的补码来表示，同时利用加法器计算减法运算，形如`a - b = a + ( - b )`，也是利用了补码的本质特性。

## 2.1 原码、反码、补码的计算
### 2.1.1 原码
将一个整数转换成二进制数，并控制符号位，就是其原码。

例如：
18 的原码为`0001 0010`
-18的原码为`1001 0010`

### 2.1.2 反码
反码规则对于正负数有所区别：
正数：反码=原码。例如：18 的反码为`0001 0010`
负数：原码中除符号位外，按位取反。例如：-18的反码为`1110 1101`

### 2.1.3 补码
补码规则对于正负数有所区别
正数：补码=原码。例如：18 的补码为`0001 0010`
负数：反码加1。例如：-18的补码为`1110 1110`

## 2.2 补码的本质是一个代替负数的正数，那么补码是如何代替一个负数，使得加法器能做减法运算呢？
在上一节中，我们介绍了补码的计算规则：负数的补码为反码+1。在这里，有另一种补码的计算方式：
$$m^n + 负数$$
m代表进制数（二进制就是2，十进制就是10），n代表位数。

例如：用8位二进制的补码表示-18，即$2^8 + (-18) = 256 - 18 = 237
转化为二进制则为`1110 1101`

现以两位数的10进制为例，展示补码如何代替一个负数，并利用加法器做减法运算
10进制中的减法运算：30 - 10 = 20
-10的补码：10^2 + (-10) = 90
利用加法来计算：30 + 90 = 120
前文已经说明 2位数的十进制，所以丢弃百位的1,即120—>20，以此利用加法与补码，得到了减法的结果。

最后，以8位的二进制演示。
👉 30的二进制补码（原码）：0001 1110
👉 - 10 的补码：1111 0110
🔑 计算过程：
   0001 1110	
 + 1111 0110
 ----------------
 1 0001 0100
1
2
3
4
丢弃最高位,即·1 0001 0100 改变成 0001 0100 = 20
⚠️扩展:由此可以看出，计算机其实解析二进制数据一直都是以无符号的方式(正数)，只不过负数的存储用了其补码，而负数的补码其实就是正数。除此之外，用丢弃超限的最高位方法，巧用加法器，实现了减法操作，从而使计算机体系中，可以区分正负数。